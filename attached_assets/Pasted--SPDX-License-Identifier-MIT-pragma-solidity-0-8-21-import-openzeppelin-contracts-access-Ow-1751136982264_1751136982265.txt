
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

/**
 * @title WalletPlanner
 * @dev Multi-Agent Wallet Planner smart contract for C-PLAN system
 * @notice This contract allows users to save wallet intents that can be executed
 * by Chainlink Automation based on specified conditions evaluated by Chainlink Functions
 * 
 * Integration with Chainlink:
 * - Chainlink Functions: Used for off-chain condition evaluation and data fetching
 * - Chainlink Automation: Used for periodic execution of intents when conditions are met
 * 
 * Example Intent Structure:
 * {
 *   user: 0x123...,
 *   action: "stake",
 *   token: 0xA0b86a33E6441e94eE9A1B6A4E7DF07d7c71D4bC,
 *   frequency: "daily",
 *   condition: "gas < 30 gwei && balance > 100 USDC",
 *   lastExecuted: 1234567890,
 *   targetChain: "ethereum",
 *   paused: false,
 *   exists: true
 * }
 */
contract WalletPlanner is Ownable, ReentrancyGuard, Pausable {
    
    /// @dev Contract version for future upgrades and compatibility
    string public constant VERSION = "1.0.0";
    
    /// @dev Maximum number of intents per user to prevent gas issues
    uint256 public constant MAX_INTENTS_PER_USER = 50;
    
    /// @dev Struct representing a wallet intent
    struct WalletIntent {
        address user;           // Owner of the intent
        string action;          // Action type: "stake", "send", "remind", "monitor", etc.
        address token;          // ERC20 token address (use address(0) for native token)
        string frequency;       // Execution frequency: "daily", "weekly", "monthly", "once"
        string condition;       // Condition string for off-chain evaluation
        uint256 lastExecuted;   // Timestamp of last execution
        string targetChain;     // Target blockchain: "ethereum", "polygon", "bsc", etc.
        bool paused;           // Whether the intent is paused
        bool exists;           // Whether the intent exists (for soft deletion)
    }
    
    /// @dev Mapping from user address to their array of intents
    mapping(address => WalletIntent[]) public userIntents;
    
    /// @dev Mapping to track total intent count per user
    mapping(address => uint256) public userIntentCount;
    
    /// @dev Mapping for authorized Chainlink automation addresses
    mapping(address => bool) public authorizedAutomation;
    
    /// @dev Events
    event IntentSaved(
        address indexed user, 
        uint256 indexed index, 
        string action, 
        address token, 
        string frequency
    );
    
    event IntentExecuted(
        address indexed user, 
        uint256 indexed index, 
        uint256 timestamp
    );
    
    event IntentPaused(
        address indexed user, 
        uint256 indexed index, 
        bool paused
    );
    
    event IntentDeleted(
        address indexed user, 
        uint256 indexed index
    );
    
    event AutomationAuthorized(address indexed automation, bool authorized);
    
    /// @dev Modifiers
    modifier onlyAuthorizedAutomation() {
        require(authorizedAutomation[msg.sender], "Not authorized automation");
        _;
    }
    
    modifier validIntentIndex(address user, uint256 index) {
        require(index < userIntents[user].length, "Invalid intent index");
        require(userIntents[user][index].exists, "Intent does not exist");
        _;
    }
    
    modifier onlyIntentOwner(address user, uint256 index) {
        require(userIntents[user][index].user == msg.sender, "Not intent owner");
        _;
    }
    
    constructor() {}
    
    /**
     * @notice Save a new wallet intent
     * @dev Stores a wallet intent that can be executed by Chainlink Automation
     * @param intent The WalletIntent struct containing all intent parameters
     */
    function saveIntent(WalletIntent memory intent) external whenNotPaused nonReentrant {
        require(userIntentCount[msg.sender] < MAX_INTENTS_PER_USER, "Max intents exceeded");
        require(bytes(intent.action).length > 0, "Action cannot be empty");
        require(bytes(intent.frequency).length > 0, "Frequency cannot be empty");
        require(bytes(intent.condition).length > 0, "Condition cannot be empty");
        require(bytes(intent.targetChain).length > 0, "Target chain cannot be empty");
        
        // Set user and ensure intent exists
        intent.user = msg.sender;
        intent.exists = true;
        intent.lastExecuted = 0; // Initialize as never executed
        
        // Add intent to user's array
        userIntents[msg.sender].push(intent);
        userIntentCount[msg.sender]++;
        
        uint256 index = userIntents[msg.sender].length - 1;
        
        emit IntentSaved(
            msg.sender, 
            index, 
            intent.action, 
            intent.token, 
            intent.frequency
        );
    }
    
    /**
     * @notice Get all intents for the calling user
     * @dev Returns array of WalletIntent structs for msg.sender
     * @return Array of user's wallet intents
     */
    function getUserIntents() external view returns (WalletIntent[] memory) {
        return userIntents[msg.sender];
    }
    
    /**
     * @notice Get intents for a specific user (paginated)
     * @dev Returns paginated array of WalletIntent structs for specified user
     * @param user The user address to query
     * @param offset Starting index for pagination
     * @param limit Maximum number of intents to return
     * @return Array of wallet intents and total count
     */
    function getUserIntentsPaginated(
        address user, 
        uint256 offset, 
        uint256 limit
    ) external view returns (WalletIntent[] memory, uint256) {
        WalletIntent[] storage allIntents = userIntents[user];
        uint256 totalCount = allIntents.length;
        
        if (offset >= totalCount) {
            return (new WalletIntent[](0), totalCount);
        }
        
        uint256 end = offset + limit;
        if (end > totalCount) {
            end = totalCount;
        }
        
        WalletIntent[] memory result = new WalletIntent[](end - offset);
        for (uint256 i = offset; i < end; i++) {
            result[i - offset] = allIntents[i];
        }
        
        return (result, totalCount);
    }
    
    /**
     * @notice Get a specific intent by user and index
     * @dev Returns a single WalletIntent struct
     * @param user The user address
     * @param index The intent index
     * @return The wallet intent
     */
    function getIntent(
        address user, 
        uint256 index
    ) external view validIntentIndex(user, index) returns (WalletIntent memory) {
        return userIntents[user][index];
    }
    
    /**
     * @notice Pause or unpause an intent
     * @dev Only the intent owner can pause/unpause their intent
     * @param index The index of the intent to pause/unpause
     * @param paused Whether to pause (true) or unpause (false) the intent
     */
    function pauseIntent(
        uint256 index, 
        bool paused
    ) external validIntentIndex(msg.sender, index) onlyIntentOwner(msg.sender, index) {
        userIntents[msg.sender][index].paused = paused;
        emit IntentPaused(msg.sender, index, paused);
    }
    
    /**
     * @notice Delete an intent (soft delete)
     * @dev Only the intent owner can delete their intent
     * @param index The index of the intent to delete
     */
    function deleteIntent(
        uint256 index
    ) external validIntentIndex(msg.sender, index) onlyIntentOwner(msg.sender, index) {
        userIntents[msg.sender][index].exists = false;
        userIntentCount[msg.sender]--;
        emit IntentDeleted(msg.sender, index);
    }
    
    /**
     * @notice Update an existing intent
     * @dev Only the intent owner can update their intent
     * @param index The index of the intent to update
     * @param intent The updated intent data
     */
    function updateIntent(
        uint256 index, 
        WalletIntent memory intent
    ) external validIntentIndex(msg.sender, index) onlyIntentOwner(msg.sender, index) whenNotPaused {
        require(bytes(intent.action).length > 0, "Action cannot be empty");
        require(bytes(intent.frequency).length > 0, "Frequency cannot be empty");
        require(bytes(intent.condition).length > 0, "Condition cannot be empty");
        require(bytes(intent.targetChain).length > 0, "Target chain cannot be empty");
        
        // Preserve user, exists flag, and lastExecuted
        intent.user = msg.sender;
        intent.exists = true;
        intent.lastExecuted = userIntents[msg.sender][index].lastExecuted;
        
        userIntents[msg.sender][index] = intent;
        
        emit IntentSaved(
            msg.sender, 
            index, 
            intent.action, 
            intent.token, 
            intent.frequency
        );
    }
    
    /**
     * @notice Check if an intent's condition is met
     * @dev This function is called by Chainlink Automation or Functions
     * The actual condition evaluation happens off-chain via Chainlink Functions
     * @param user The user address owning the intent
     * @param index The intent index
     * @return Whether the condition is met (determined off-chain)
     */
    function checkCondition(
        address user, 
        uint256 index
    ) external view validIntentIndex(user, index) returns (bool) {
        WalletIntent memory intent = userIntents[user][index];
        
        // Basic checks before off-chain evaluation
        if (intent.paused || !intent.exists) {
            return false;
        }
        
        // Check frequency-based timing
        if (bytes(intent.frequency).length > 0) {
            uint256 timeSinceLastExecution = block.timestamp - intent.lastExecuted;
            
            if (keccak256(bytes(intent.frequency)) == keccak256(bytes("daily"))) {
                if (timeSinceLastExecution < 1 days) return false;
            } else if (keccak256(bytes(intent.frequency)) == keccak256(bytes("weekly"))) {
                if (timeSinceLastExecution < 7 days) return false;
            } else if (keccak256(bytes(intent.frequency)) == keccak256(bytes("monthly"))) {
                if (timeSinceLastExecution < 30 days) return false;
            }
        }
        
        // NOTE: Actual condition evaluation (gas price, balance checks, etc.) 
        // should be performed off-chain via Chainlink Functions
        // This function returns true to indicate basic checks passed
        // The off-chain component will perform the detailed condition evaluation
        return true;
    }
    
    /**
     * @notice Mark an intent as executed
     * @dev Called by authorized Chainlink Automation after successful execution
     * @param user The user address owning the intent
     * @param index The intent index
     */
    function markExecuted(
        address user, 
        uint256 index
    ) external validIntentIndex(user, index) onlyAuthorizedAutomation nonReentrant {
        userIntents[user][index].lastExecuted = block.timestamp;
        emit IntentExecuted(user, index, block.timestamp);
    }
    
    /**
     * @notice Authorize or deauthorize Chainlink automation addresses
     * @dev Only owner can manage automation authorization
     * @param automation The automation address
     * @param authorized Whether to authorize or deauthorize
     */
    function setAutomationAuthorization(
        address automation, 
        bool authorized
    ) external onlyOwner {
        authorizedAutomation[automation] = authorized;
        emit AutomationAuthorized(automation, authorized);
    }
    
    /**
     * @notice Get the total number of active intents for a user
     * @dev Returns count of non-deleted intents
     * @param user The user address
     * @return The number of active intents
     */
    function getActiveIntentCount(address user) external view returns (uint256) {
        return userIntentCount[user];
    }
    
    /**
     * @notice Emergency pause contract
     * @dev Only owner can pause the contract
     */
    function emergencyPause() external onlyOwner {
        _pause();
    }
    
    /**
     * @notice Unpause contract
     * @dev Only owner can unpause the contract
     */
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /**
     * @notice Get contract info
     * @dev Returns basic contract information
     * @return version The contract version
     * @return maxIntentsPerUser Maximum intents allowed per user
     * @return paused Whether the contract is paused
     */
    function getContractInfo() external view returns (
        string memory version,
        uint256 maxIntentsPerUser,
        bool paused
    ) {
        return (VERSION, MAX_INTENTS_PER_USER, paused());
    }
}
